package ru.whiteleaf.notes.data.datasource

import android.content.Context
import ru.whiteleaf.notes.common.AppConstants.DEFAULT_DIR
import ru.whiteleaf.notes.data.config.NotebookConfigManager
import java.io.File


class FileNoteDataSource(
    private val context: Context,
    private val configManager: NotebookConfigManager,
    private val encryptionManager: EncryptionManager
) {

    val baseDir: File by lazy {
        File(context.filesDir, DEFAULT_DIR).apply {
            if (!exists()) {
                mkdirs()
            }
        }
    }

    fun getNoteFile(notebookPath: String, noteId: String): File {
        val dir = if (notebookPath.isNotEmpty()) {
            File(baseDir, notebookPath).apply {
                if (!exists()) {
                    mkdirs()
                }
            }
        } else {
            baseDir
        }
        return File(dir, "$noteId.txt")
    }

    // –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏
    fun deleteNote(notebookPath: String, noteId: String): Boolean {
        val file = getNoteFile(notebookPath, noteId)
        return if (file.exists()) {
            file.delete()
        } else {
            false
        }
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞
    fun existsNote(notebookPath: String, noteId: String): Boolean {
        val file = getNoteFile(notebookPath, noteId)
        return file.exists()
    }

    fun readNoteContent(file: File, notebookPath: String): String {
        val content = file.readText()
        println("üìñ readNoteContent - notebook: $notebookPath")

        return if (configManager.isNotebookProtected(notebookPath) && encryptionManager != null) {
            val keyAlias = configManager.getKeyAliasForNotebook(notebookPath)!!
            println("üîì Notebook is protected, key: $keyAlias")

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç - –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã –ª–∏ —É–∂–µ –¥–∞–Ω–Ω—ã–µ?
            val isEncryptedFormat = content.contains("|") && content.split("|").size == 2
            println("üîì Is encrypted format: $isEncryptedFormat")

            if (isEncryptedFormat) {
                // –î–∞–Ω–Ω—ã–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã - –ø—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å (–º–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å –±–∏–æ–º–µ—Ç—Ä–∏—é)
                println("üîì Attempting to decrypt encrypted content")
                try {
                    val decrypted = encryptionManager.decryptContent(content, keyAlias)
                    if (decrypted != content) {
                        println("‚úÖ Successfully decrypted")
                        decrypted
                    } else {
                        println("‚ùå Decryption failed but format was encrypted")
                        throw SecurityException("Biometric authentication required")
                    }
                } catch (e: SecurityException) {
                    println("üîê SecurityException - biometric required for decryption")
                    throw e
                }
            } else {
                // –î–∞–Ω–Ω—ã–µ –ù–ï –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
                println("üìù Content is not encrypted, returning as-is")
                content
            }
        } else {
            println("üìù Notebook not protected, returning plain text")
            content
        }
    }

    fun writeNoteContent(file: File, content: String, notebookPath: String) {
        val contentToWrite = if (configManager.isNotebookProtected(notebookPath) && encryptionManager != null) {
            val keyAlias = configManager.getKeyAliasForNotebook(notebookPath)!!
            encryptionManager.encryptContent(content, keyAlias)
        } else {
            content
        }

        file.writeText(contentToWrite)
    }


    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è
    fun setFileLastModified(file: File, timestamp: Long) {
        file.setLastModified(timestamp)
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    fun listFilesInDirectory(directory: File): Array<File>? {
        return directory.listFiles()
    }

    // –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    fun createDirectory(directory: File): Boolean {
        return directory.mkdirs()
    }

    // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ/–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
    fun moveFile(source: File, target: File): Boolean {
        return if (source.renameTo(target)) {
            true
        } else {
            // –ï—Å–ª–∏ renameTo –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –∫–æ–ø–∏—Ä—É–µ–º –∏ —É–¥–∞–ª—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª
            try {
                source.copyTo(target, overwrite = true)
                source.delete()
                true
            } catch (_: Exception) {
                false
            }
        }
    }
}
